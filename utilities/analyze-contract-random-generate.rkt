#lang racket
(require "make-typed-configurations.rkt")

#|
The following script tries to run contract-exercise on all of non-flat contracts (generated by TR) in gtp-benchmarks
1. Scan over benchmarks modules
2. For each module, call `module->exports` to get the list of values `provide`d as symbols
3. For each symbol, call `dynamic-require` to get the value from the module
4. Call `contract-value` to get the contract on the module
5. Exercise
|#

(define dflt-out (current-output-port))

; Print a line of the form "~a,...\n"  where each argument is comma-separated to the default output port
(define-syntax print-analysis
  (syntax-rules ()
    [(_ info ... lst) (fprintf dflt-out "~a,~a,~a,~a\n"
                               info ... (if (equal? #t lst) lst (string-replace lst "\n" "\\n")))]))

; path-to-module symbol value contract -> void
; print output: abridged-path, symbol, contract, crg-works? 
(define (analyze-contract mod-path sym val ctc)
; We need a custodian to limit memory because the fsm benchmark runs out of memory
  (define s (open-output-string)) ; Fake output port to capture any printing from *inside* benchmarks
  (parameterize ([current-custodian (make-custodian)]
                 [current-output-port s])
    (thread-wait
     (thread
      (位 ()
        (with-handlers ([exn:fail?
                         (位 (e) (print-analysis mod-path sym ctc (exn-message e)))]) ; print error message
          (custodian-limit-memory (current-custodian) (* 1024 1024)) 
          ; first, check if we can actually create a generator for the function's domains (assuming the input is a function)
          (for-each contract-random-generate (base->-doms/c ctc)) ; raises exception if it cannot create a generator
          (contract-exercise val)  ; exercise the function
          (print-analysis mod-path sym ctc #t))))))) ; no error found via exercise
  

; path -> path
; Example: ../fully-typed-benchmarks/acquire/typed/something.rkt -> acquire/typed/something.rkt
(define (abridged-path p)
  (define pieces (take-right (explode-path p) 3)) ; get the benchmark-name/base|typed/module-name.rkt in a list
  (build-path (first pieces) (second pieces) (third pieces)))

; path to rkt file -> void
; loop over all exports from the file and call analyze-contract on them
(define (scan-file module-path)
  (define a-path (abridged-path module-path))
  (dynamic-require module-path 0) ; we need require for module->exports to work
  (define-values [val-exports stx-exports] (module->exports module-path))
  (define syms
    (append (if (empty? val-exports) '() (map first (rest (assoc 0 val-exports))))
            (if (empty? stx-exports) '() (map first (rest (assoc 0 stx-exports))))))
  (for* ([sym (in-list syms)] ; loop over results from module->exports
         [val (in-value ; get the value of the export from the module
               (with-handlers ([exn:fail? (位 (e) #false)])
                 (dynamic-require module-path sym)))]
         #:when val
         [ctc (in-value (value-contract val))] ; get the contract from the value
         #:when (and ctc (not (flat-contract? ctc)))) ; skip boring contracts
    (analyze-contract a-path sym val ctc)))

; path -> Bool
; Exclude files with import errors or that don't provide anything
(define (relevant-file? p)
  (and (equal? #".rkt" (path-get-extension p))
       (not (member (path->string (file-name-from-path p))
                    (list "main.rkt" "run-t.rkt" "kcfa-typed.rkt")))))

; String Symbol -> void
; Run analyze-contracts on a given contract
(define (one-test a-path sym)
  (define module-path (build-path typed-dir a-path))
  (dynamic-require module-path 0) ; we need require for module->exports to work
  (define val (with-handlers ([exn:fail? (位 (e) #false)])
                (dynamic-require module-path sym)))
  (printf "Exercising ~a\n" val)
  (contract-exercise val)
  #;(if val 
        (analyze-contract a-path sym val (value-contract val))
        (error 'one-test "Could not find ~a ~a ~a" module-path sym)))


; loop over each module ; NOTE: can be simplified as there should not be files at 2 different levels
(for* ([benchmark (directory-list typed-dir #:build? #t)]
       [subdir (directory-list benchmark #:build? #t)]
       [b-module (directory-list subdir #:build? #t)]
       #:when (and (relevant-file? b-module)
                   #;(string-contains? (path->string b-module) "fsm")))
  (scan-file b-module))
