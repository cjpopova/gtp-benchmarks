#lang racket
(require "create-typed-configs.rkt")

#|
The following script tries to run contract-random-generate on all of non-flat contracts (generated by TR) in gtp-benchmarks
1. Scan over benchmarks modules
2. For each module, call `module->exports` to get the list of values `provide`d as symbols
3. For each symbol, call `dynamic-require` to get the value from the module
4. Call `contract-value` to get the contract on the module
5. generate
|#


; Print a line of the form "~a,...\n"  where each argument is comm`a-separated
(define-syntax print-analysis
  (syntax-rules ()
    [(_ info ...) (printf "~a,~a,~a,~a\n" info ...)]))

; path-to-module symbol contract -> void
; print output: abridged-path, symbol, contract, crg-works? 
(define (analyze-contract mod-path sym ctc)
  (with-handlers ([exn:fail? (λ (e) (print-analysis mod-path sym ctc 0))])
    (contract-random-generate ctc)
    (print-analysis mod-path sym ctc 1)))

; path -> path
; Example: ../fully-typed-benchmarks/acquire/typed/something.rkt -> acquire/typed/something.rkt
(define (abridged-path p)
  (define pieces (take-right (explode-path p) 3)) ; get the benchmark-name/base|typed/module-name.rkt in a list
  (build-path (first pieces) (second pieces) (third pieces)))

; path to rkt file -> void
; loop over all exports from the file and call analyze-contract on them
(define (scan-file module-path)
  (define a-path (abridged-path module-path))
  (dynamic-require module-path 0) ; we need require for module->exports to work
  (define-values [val-exports stx-exports] (module->exports module-path))
  (define syms
    (append (if (empty? val-exports) '() (map first (rest (assoc 0 val-exports))))
            (if (empty? stx-exports) '() (map first (rest (assoc 0 stx-exports))))))
  (for* ([sym (in-list syms)] ; loop over results from module->exports
         [val (in-value ; get the value of the export from the module
               (with-handlers ([exn:fail? (λ (e) #false)])
                 (dynamic-require module-path sym)))]
         #:when val
         [ctc (in-value (value-contract val))] ; get the contract from the value
         #:when (and ctc (not (flat-contract? ctc)))) ; skip boring contracts
    (analyze-contract a-path sym ctc)
    #;(with-handlers ([exn:fail? (λ (e)
                                   (printf "\n~a ~a\n" module-path sym)
                                   (displayln e))])
        (contract-exercise val))))

; path -> Bool
; Exclude files with import errors or that don't provide anything
(define (relevant-file? p)
  (and (equal? #".rkt" (path-get-extension p))
       (not (member (path->string (file-name-from-path p))
                    (list "main.rkt" "run-t.rkt" "kcfa-typed.rkt")))))


; loop over each module ; NOTE: can be simplified as there should not be files at 2 different levels
(for* ([benchmark (directory-list typed-dir #:build? #t)]
       [subdir (directory-list benchmark #:build? #t)]
       [b-module (directory-list subdir #:build? #t)]
       #:when (relevant-file? b-module))
  (scan-file b-module))
