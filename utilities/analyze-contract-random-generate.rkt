#lang racket
(require "make-typed-configurations.rkt")

#|
The following script tries to run contract-random-generate on all of non-flat contracts (generated by TR) in gtp-benchmarks
1. Scan over benchmarks modules
2. For each module, call `module->exports` to get the list of values `provide`d as symbols
3. For each symbol, call `dynamic-require` to get the value from the module
4. Call `contract-value` to get the contract on the module
5. generate
|#


; Print a line of the form "~a,...\n"  where each argument is comma-separated
(define-syntax print-analysis
  (syntax-rules ()
    [(_ info ...) (printf "~a,~a,~a,~a\n" info ...)]))

; path-to-module symbol value contract -> void
; print output: abridged-path, symbol, contract, crg-works? 
(define (analyze-contract mod-path sym val ctc)
  (with-handlers ([exn:fail?
                   (位 (e)

                     (print-analysis mod-path sym ctc (exn-message e))
                     #;(if (regexp-match
                            #rx"contract-random-generate: unable to construct any generator for contract.*"
                            (exn-message e))
                           (print-analysis mod-path sym ctc 2)
                           (print-analysis mod-path sym ctc 0)))])
    ; first, check if we can actually create a generator for the function's domains (assuming the input is a function)
    (for-each contract-random-generate (base->-doms/c ctc)) ; raises exception if it cannot create a generator
    (contract-exercise val) ; exercise the function
    (print-analysis mod-path sym ctc 1))) ; 1 = no error found via exercise

; path -> path
; Example: ../fully-typed-benchmarks/acquire/typed/something.rkt -> acquire/typed/something.rkt
(define (abridged-path p)
  (define pieces (take-right (explode-path p) 3)) ; get the benchmark-name/base|typed/module-name.rkt in a list
  (build-path (first pieces) (second pieces) (third pieces)))

; path to rkt file -> void
; loop over all exports from the file and call analyze-contract on them
(define (scan-file module-path)
  (define a-path (abridged-path module-path))
  (dynamic-require module-path 0) ; we need require for module->exports to work
  (define-values [val-exports stx-exports] (module->exports module-path))
  (define syms
    (append (if (empty? val-exports) '() (map first (rest (assoc 0 val-exports))))
            (if (empty? stx-exports) '() (map first (rest (assoc 0 stx-exports))))))
  (for* ([sym (in-list syms)] ; loop over results from module->exports
         [val (in-value ; get the value of the export from the module
               (with-handlers ([exn:fail? (位 (e) #false)])
                 (dynamic-require module-path sym)))]
         #:when val
         [ctc (in-value (value-contract val))] ; get the contract from the value
         #:when (and ctc (not (flat-contract? ctc)))) ; skip boring contracts
    (analyze-contract a-path sym val ctc)
    #;(with-handlers ([exn:fail? (位 (e)
                                   (printf "\n~a ~a\n" module-path sym)
                                   (displayln e))])
        (contract-exercise val))))

; path -> Bool
; Exclude files with import errors or that don't provide anything
(define (relevant-file? p)
  (and (equal? #".rkt" (path-get-extension p))
       (not (member (path->string (file-name-from-path p))
                    (list "main.rkt" "run-t.rkt" "kcfa-typed.rkt")))))

; String Symbol -> void
; Run analyze-contracts on a given contract
(define (one-test a-path sym)
  (define module-path (build-path typed-dir a-path))
  (dynamic-require module-path 0) ; we need require for module->exports to work
  (define val (with-handlers ([exn:fail? (位 (e) #false)])
                (dynamic-require module-path sym)))
  (printf "Exercising ~a\n" val)
  (contract-exercise val)
  #;(if val 
        (analyze-contract a-path sym val (value-contract val))
        (error 'one-test "Could not find ~a ~a ~a" module-path sym)))


; loop over each module ; NOTE: can be simplified as there should not be files at 2 different levels
(for* ([benchmark (directory-list typed-dir #:build? #t)]
         [subdir (directory-list benchmark #:build? #t)]
         [b-module (directory-list subdir #:build? #t)]
         #:when (and (relevant-file? b-module)
                     (string-contains? (path->string b-module) "gregor")))
    (scan-file b-module))
